[![Hits](https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fgithub.com%2FJhonnySMarcelo%2FLearning&count_bg=%2379C83D&title_bg=%23555555&icon=&icon_color=%23E7E7E7&title=Views&edge_flat=false)](https://hits.seeyoufarm.com)


# Learning (ğŸš§ **Em ConstruÃ§Ã£o** )

## ProgramaÃ§Ã£o (ğŸš§)

## Banco de Dados (ğŸš§)
### Relacional (Sequel, SQL) (ğŸš§)
**SQL Server** (ğŸš§)
- ConfiguraÃ§Ã£o do Ambiente de desenvolvimento (ğŸš§)
- Modelagem de Dados (ğŸš§)
- Consultas SQL (ğŸš§)
- FunÃ§Ãµes de AgregaÃ§Ã£o e OperaÃ§Ãµes de Conjuntos (ğŸš§)
- Stored Procedures (ğŸš§)
- Triggers (ğŸš§)
- Ãndices (ğŸš§)
- VisÃµes (Views) (ğŸš§)

### NÃ£o Relacional (NoSQL) (ğŸš§)

### Back-end (ğŸš§)
[C# .Net](Back-end/C%23_DotNet.md) (ğŸš§)
- ConfiguraÃ§Ã£o do Ambiente de desenvolvimento(ğŸš§)
- LÃ³gica de programaÃ§Ã£o (ğŸš§)
	- Algoritmos e sua importÃ¢ncia (ğŸš§)
	- VariÃ¡veis e tipos de dados (ğŸš§)
	- Operadores lÃ³gicos e relacionais (ğŸš§)
    - Estruturas condicionais (if, else, switch) (ğŸš§)
    - Estruturas de repetiÃ§Ãµes Loops (for, while, do-while) (ğŸš§)
    - Controle de fluxo (break, continue) (ğŸš§)
    - DefiniÃ§Ã£o e aplicaÃ§Ã£o de funÃ§Ãµes (ğŸš§)
    - Passagem de parÃ¢metros (por valor, por referÃªncia) (ğŸš§)
    - FunÃ§Ãµes recursivas (ğŸš§)
		- Conceitos bÃ¡sicos de recursÃ£o (ğŸš§)
		- AplicaÃ§Ãµes prÃ¡ticas de recursÃ£o (ğŸš§)
    - ManipulaÃ§Ã£o de strings e caracteres (ğŸš§)
- Estrutura de dados (ğŸš§)
	- DefiniÃ§Ã£o e aplicaÃ§Ã£o (ğŸš§)
	- Arrays e Matrizes (ğŸš§)
    - OperaÃ§Ãµes bÃ¡sicas (inserÃ§Ã£o, remoÃ§Ã£o, acesso)  (ğŸš§)
	- Listas Ligadas  (ğŸš§)
		- Simplesmente encadeadas (ğŸš§)
		- Duplamente encadeadas (ğŸš§)
	- Pilhas e Filas (ğŸš§)
	- Ãrvores (ğŸš§)
		- Ãrvores binÃ¡rias (ğŸš§)
	- Grafos (ğŸš§)
		- RepresentaÃ§Ã£o de grafos (ğŸš§)
    - Algoritmos de busca em grafos (ğŸš§)
	- Tabelas Hash (ğŸš§)
- ProgramaÃ§Ã£o Orientada a Objetos POO (Object Oriented Programming, OOP) (ğŸš§)
	- Conceitos Fundamentais de POO (ğŸš§)
	- Classes e Objetos (ğŸš§)
	- Encapsulamento, HeranÃ§a e Polimorfismo (ğŸš§)
	- AbstraÃ§Ã£o e Interfaces (ğŸš§)
	- Delegates e Eventos (ğŸš§)
	- Extension Methods e Operator Overloading (ğŸš§)
	- Finalizadores (Destructors) e IDisposable (ğŸš§)
- Acesso a Dados (ğŸš§)
  -  Mapeamento objeto-relacional (Object-Relational Mapping, ORM) (ğŸš§)
	- Eager Loading (ğŸš§)
	- Lazy Loaging (ğŸš§)
	- Entity FrameWork Core (ğŸš§)
		- ConfiguraÃ§Ã£o e Mapeamento (ğŸš§)
		- Relacionamentos e Consultas (ğŸš§)
	- Dapper (ğŸš§)
 	- Provedores de dados (Data Providers) (ğŸš§)
		- ADO.Net (ğŸš§)
		- DevArt dotConnect (ğŸš§)
- AutenticaÃ§Ã£o e AutorizaÃ§Ã£o (ğŸš§)
  - AutenticaÃ§Ã£o Baseada em Cookies (ğŸš§)
  - AutorizaÃ§Ã£o Baseada em FunÃ§Ãµes (Role-Based Authorization)    (ğŸš§)
  - JSON Web Token (JWT) (ğŸš§)
  - OAuth e OpenID Connect (ğŸš§)
  - AutorizaÃ§Ã£o Baseada em Claims (Claim-Based Authorization) (ğŸš§)
  - Controle de Acesso Baseado em Recursos (Resource-Based Access Control) (ğŸš§)
-  ASP.NET (ğŸš§)
	- IntroduÃ§Ã£o ao ASP.NET (ğŸš§)
	- Web API arquitetura RESTful (ğŸš§)
		- APIs baseadas em controlador (Controller-based APIs) (ğŸš§)
		- APIs mÃ­nimas (Minimal APIs) (ğŸš§)
		- Webhooks (ğŸš§)
	- Paginas Web (Web App) (ğŸš§)
		- MVC Modelo-VisualizaÃ§Ã£o-Controlador (Model-View-Controller) (ğŸš§)
		- PÃ¡ginas Razor (ğŸš§)
- Logs (Registros) e Monitoramento  (ğŸš§)
	- ImplementaÃ§Ã£o de Logs Simples  (ğŸš§)
	- ImplementaÃ§Ã£o de Logs Estruturado e AnÃ¡lise de Logs (ğŸš§)
- Arquitetura de Software (ğŸš§)
	- DefiniÃ§Ã£o e importÃ¢ncia da arquitetura de software.
    - PrincÃ­pios fundamentais (Separation of Concerns, Modularity, etc.).
    - Qualidades Arquiteturais (Performance, Scalability, Security, etc.).
    - Estilos Arquiteturais
		- Monolithic (MonolÃ­tico)
		- Microservices (MicrosserviÃ§os)
		- Event-Driven (Orientado a Eventos) (ğŸš§)
		- N-tier Architecture (Arquitetura Multicamadas) (ğŸš§)
		- Serverless (Sem Servidor) (ğŸš§)
- PadrÃµes de Projeto (Design Patterns) (ğŸš§)
	- IntroduÃ§Ã£o aos PadrÃµes de Projeto (ğŸš§)
	- PadrÃµes Creational (ğŸš§)
	- PadrÃµes Estruturais (Structural)  (ğŸš§)
		- [InjeÃ§Ã£o de DependÃªncia (Dependency Injection)](Back-end/CSharp_DotNet/Padroes_de_Projeto/Padroes_Estruturais/Injecao_de_Dependencia.md)
			- Conceito e importÃ¢ncia da InjeÃ§Ã£o de DependÃªncia
			- Tempo de vida (Lifetime)
				- Transient
				- Scoped
				- Singleton
			- Tipos de InjeÃ§Ã£o de DependÃªncia
				- InjeÃ§Ã£o via interface
				- InjeÃ§Ã£o via Construtor (Constructor)
				- InjeÃ§Ã£o via Propriedade (Setter)
			- ImplementaÃ§Ã£o de InjeÃ§Ã£o de DependÃªncia em C# (ğŸš§)
			- Frameworks de InjeÃ§Ã£o de DependÃªncia (Autofac, Microsoft DI, etc.) (ğŸš§)
	- PadrÃµes Behavioral (ğŸš§)
- PadrÃµes Arquiteturais
    - MVC (Model-View-Controller) (ğŸš§)
    - SOA (Service-Oriented Architecture) (ğŸš§)
    - Layered Architecture (ğŸš§)
    - Clean Architecture (ğŸš§)
    - Ports and Adapters (Hexagonal Architecture) (ğŸš§)
    - DocumentaÃ§Ã£o (UML, C4, etc.).
- PrincÃ­pios de Design de Software (Software Design Principles) (ğŸš§)
	- PrincÃ­pios SOLID (ğŸš§)
		- S - Single Responsibility Principle (SRP): Uma classe deve ter apenas uma responsabilidade ou motivo para mudar.
        - O - Open/Closed Principle (OCP): Entidades de software devem estar abertas para extensÃ£o, mas fechadas para modificaÃ§Ã£o.
        - L - Liskov Substitution Principle (LSP): Objetos de uma classe base devem poder ser substituÃ­dos por objetos de uma classe derivada sem alterar o comportamento esperado.
        - I - Interface Segregation Principle (ISP): Uma interface deve ser especÃ­fica para um cliente, nÃ£o genÃ©rica para vÃ¡rios clientes.
        - D - Dependency Inversion Principle (DIP): Dependa de abstraÃ§Ãµes e nÃ£o de implementaÃ§Ãµes concretas.
    - PrincÃ­pios de Simplicidade (ğŸš§)
		- KISS (Keep It Simple, Stupid): Mantenha o design e o cÃ³digo o mais simples possÃ­vel.
		- YAGNI (You Aren't Gonna Need It): NÃ£o adicione funcionalidades atÃ© que realmente precise delas.
    - PrincÃ­pios de Modularidade e Encapsulamento (ğŸš§)
        - Separation of Concerns (SoC): Divida o sistema em partes distintas que lidam com diferentes aspectos.
        - Encapsulation (Encapsulamento): Proteja os dados e comportamentos internos de um objeto, expondo apenas o necessÃ¡rio.
    - PrincÃ­pios de Acoplamento e CoesÃ£o (ğŸš§)
        - Law of Demeter (Lei de Demeter): Um objeto deve interagir apenas com seus amigos diretos e nÃ£o com os amigos dos amigos.
        - Tell, Don't Ask (Diga, NÃ£o Pergunte): Diga ao objeto o que fazer diretamente, sem perguntar sobre seu estado.
    - PrincÃ­pios de Flexibilidade e EvoluÃ§Ã£o (ğŸš§)
        - Favor Composition Over Inheritance (Prefira ComposiÃ§Ã£o Ã  HeranÃ§a): Utilize composiÃ§Ã£o em vez de heranÃ§a para criar sistemas flexÃ­veis.
        - Principle of Flexibility (PrincÃ­pio da Flexibilidade): O design deve permitir mudanÃ§as e extensÃµes futuras com facilidade.
    - PrincÃ­pios de Robustez e ManutenÃ§Ã£o (ğŸš§)
        - DRY (Don't Repeat Yourself): Evite duplicaÃ§Ã£o de cÃ³digo e lÃ³gica.
        - Principle of Maintainability (PrincÃ­pio da Manutenibilidade): O cÃ³digo deve ser fÃ¡cil de entender, corrigir e atualizar.
        - Principle of Robustness (PrincÃ­pio da Robustez): O sistema deve lidar com condiÃ§Ãµes inesperadas e erros de forma eficaz.
    - PrincÃ­pios de AbstraÃ§Ã£o e InteraÃ§Ã£o (ğŸš§)
        - Principle of Abstraction (PrincÃ­pio de AbstraÃ§Ã£o): Esconda detalhes complexos e forneÃ§a uma interface simplificada.
        - Single Source of Truth (Fonte Ãšnica da Verdade): A informaÃ§Ã£o deve ser representada em um Ãºnico lugar para garantir consistÃªncia.
    - PrincÃ­pios de Design de Interface (ğŸš§)
        - Principle of Least Astonishment (PrincÃ­pio do Menor Espanto): O design deve ser previsÃ­vel para minimizar a surpresa e a confusÃ£o.

## IntegraÃ§Ã£o com SDLC e DevOps (ğŸš§)
- SDLC (Software Development Life Cycle) (ğŸš§)
	- Modelos de SDLC (ğŸš§)
		- Waterfall (Cascata) (ğŸš§)
		- Agile (Scrum, Kanban, XP, etc.) (ğŸš§)
		- DevSecOps como modelo integrado de seguranÃ§a no ciclo de vida (ğŸš§)
	- Fases do SDLC no desenvolvimento .NET (ğŸš§)
		- Levantamento de Requisitos (ğŸš§)
        - AnÃ¡lise e Planejamento  (ğŸš§)
        - Design (Arquitetura em camadas, Clean Architecture, DDD) (ğŸš§)
        - ImplementaÃ§Ã£o (ASP.NET MVC/Core, Entity Framework, C#) (ğŸš§)
        - Testes (UnitÃ¡rios com xUnit, IntegraÃ§Ã£o, Automatizados com Selenium/Playwright) (ğŸš§)
        - Deploy (Pipelines no Azure DevOps, GitHub Actions, Octopus Deploy) (ğŸš§)
        - ManutenÃ§Ã£o e Suporte (Logs, Telemetria com Application Insights) (ğŸš§)
    - PapÃ©is no SDLC (ğŸš§)
        - Product Owner, Scrum Master, Devs, QA, DevOps Engineer (ğŸš§)
    - DocumentaÃ§Ã£o no SDLC (ğŸš§)
        - Requisitos Funcionais e NÃ£o Funcionais (ğŸš§)
        - Documentos TÃ©cnicos (ERDs, Diagramas UML, Swagger/OpenAPI para APIs) (ğŸš§)
        - Versionamento de DocumentaÃ§Ã£o (Markdown, DocFX, Docusaurus) (ğŸš§)
	- AplicaÃ§Ã£o das fases do SDLC no desenvolvimento .NET (ğŸš§)
- DevOps (ğŸš§)
	- Conceitos Fundamentais (ğŸš§)
        - Cultura DevOps (colaboraÃ§Ã£o entre Dev + Ops) (ğŸš§)
        - CALMS Framework (Culture, Automation, Lean, Measurement, Sharing) (ğŸš§)
        - DevOps vs Agile: complementares, nÃ£o concorrentes (ğŸš§)
        - MÃ©tricas: Lead Time, Deployment Frequency, Mean Time to Recovery (MTTR), Change Failure Rate (ğŸš§)
    - AutomaÃ§Ã£o de Processos (ğŸš§)
        - Infraestrutura como CÃ³digo (IaC) com Bicep, Terraform, Pulumi (foco em Azure) (ğŸš§)
        - AutomatizaÃ§Ã£o de builds com MSBuild, dotnet CLI (ğŸš§)
        - Testes Automatizados no pipeline (ğŸš§)
        - AutomatizaÃ§Ã£o de Deploys (Blue/Green, Canary, Rolling Updates) (ğŸš§)
    - CI/CD com .NET
        - CI (IntegraÃ§Ã£o ContÃ­nua): build, testes, anÃ¡lise de cÃ³digo (SonarQube) (ğŸš§)
        - CD (Entrega/ImplantaÃ§Ã£o ContÃ­nua): artefatos, staging/prod (ğŸš§)
        - Ferramentas: (ğŸš§)
            - Azure DevOps (YAML Pipelines) (ğŸš§)
            - GitHub Actions (com dotnet CLI) (ğŸš§)
            - GitLab CI/CD (ğŸš§)
            - Jenkins (menos comum em .NET, mas possÃ­vel) (ğŸš§)
            - Octopus Deploy (ğŸš§)
    - ContÃªineres e OrquestraÃ§Ã£o (ğŸš§)
        - Docker: (ğŸš§)
            - Dockerfile para apps ASP.NET Core (ğŸš§)
            - Multistage builds (ğŸš§)
            - Docker Compose para apps multicamadas (.NET + SQL Server) (ğŸš§)
        - Kubernetes: (ğŸš§)
            - Helm Charts para apps .NET (ğŸš§)
            - Azure Kubernetes Service (AKS) (ğŸš§)
            - Monitoramento com Prometheus + Grafana (ğŸš§)
            - Kustomize, KEDA para escalonamento (ğŸš§)
    - Monitoramento e Observabilidade (ğŸš§)
        - Application Insights (Azure) (ğŸš§)
        - Serilog + Seq para logs estruturados (ğŸš§)
        - OpenTelemetry com .NET (ğŸš§)
        - Health Checks nativos (.NET Core) (ğŸš§)
    - SeguranÃ§a Integrada (DevSecOps) (ğŸš§)
        - Static Code Analysis: SonarQube, Snyk (ğŸš§)
        - Dependabot (GitHub) (ğŸš§)
        - Secrets Management (Azure Key Vault, dotenv) (ğŸš§)
        - PolÃ­ticas de Branch, PR e RevisÃ£o de CÃ³digo (ğŸš§)
        - Testes de SeguranÃ§a Automatizados (ğŸš§)
    - Release Management (ğŸš§)
        - Versionamento SemÃ¢ntico (Semantic Versioning) (ğŸš§)
        - Tagging automÃ¡tico no Git (ğŸš§)
        - GitFlow / trunk-based development (ğŸš§)
        - Gerenciamento de Releases com Azure DevOps Boards, Jira (ğŸš§)
    - Feature Flags e Releases Controladas (ğŸš§)
        - LaunchDarkly, Azure App Configuration (ğŸš§)
        - A/B Testing e Canary Deployments com flags (ğŸš§)
        - Exemplo prÃ¡tico com ASP.NET e App Configuration (ğŸš§)

### Front-end (ğŸš§)
- HTML 5 (HyperText Markup Language) (ğŸš§)
- CSS 3 (Cascading Style Sheets) (ğŸš§)
- JavaScript (ğŸš§)
	- Vanilla (ğŸš§)
	- TYPESCRIPT (ğŸš§)
- Bootstrap (ğŸš§)

## Angular (ğŸš§)
- IntroduÃ§Ã£o ao Angular (ğŸš§)
- [ConfiguraÃ§Ã£o do Ambiente de Desenvolvimento (ğŸš§)](Front-end/Angular/ConfiguraÃ§Ã£o_do_Ambiente_de_Desenvolvimento.md)
- Angular CLI (ğŸš§)
- Componentes e Templates (ğŸš§)
- ServiÃ§o e InjeÃ§Ã£o de dependÃªncia (Dependency injection) (ğŸš§)
- Data Binding (InterpolaÃ§Ã£o, Propriedade, Evento, Duas Vias (Two-Away)) (ğŸš§)
- Diretivas (Estruturais, Atributo )(ğŸš§)
- Operador Elvis ("?") (ğŸš§)
- Pipes (ğŸš§)
- FormulÃ¡rios (ğŸš§)
- Roteamento (ğŸš§)
- IntegraÃ§Ã£o com Servidor (ğŸš§)
- ComunicaÃ§Ã£o com Backend e Observables (ğŸš§)

### Mobile

### Flutter
- IntroducÃ£o ao Flutter
- Command Line Interface (CLI)
	- Slidy 
- Sistema de injeÃ§Ã£o de depÃªncia e controle de rotas
	- Modular
- GestÃ£o de estado
	- MOBX 
- Linguagem de design
	- Material Design 
- PersistÃªncia de Dados 

## Versionamento de CÃ³digo (ğŸš§)
### Git  (ğŸš§)
- InstalÃ§Ã£o
- IntroduÃ§Ã£o ao GIT
   - Conceito de controle de versÃ£o e sua importÃ¢ncia.
   - Vantagens do Git.

- Comandos BÃ¡sicos
    - ConfiguraÃ§Ã£o Inicial
	- Inicializar RepositÃ³rio
	- Clonar RepositÃ³rio
	- Status do RepositÃ³rio
	- Adicionar AlteraÃ§Ãµes
	- Criar Commit
	- Enviar AlteraÃ§Ãµes para o RepositÃ³rio Remoto
	- Atualizar o RepositÃ³rio Local
- Branching e Merging
    - Criar uma Nova Branch
	- Mudar para uma Branch
	- Unir AlteraÃ§Ãµes de uma Branch
- ResoluÃ§Ã£o de Conflitos
    - ExplicaÃ§Ã£o de como resolver conflitos e boas prÃ¡ticas para evitÃ¡-los.
- .gitignore
    - DescriÃ§Ã£o de como configurar arquivos a serem ignorados.
    - Exemplo
- ConfiguraÃ§Ã£o de RepositÃ³rios Remotos
    - Adicionar repositÃ³rio remoto
	- Verificar repositÃ³rios remotos
Fluxos de Trabalho (Workflows)
    - Git Flow
        - Branches principais 
            - main
            - develop
        - Branches auxiliares
            - feature/
            - release/
            - hotfix/
    Trunk-Based Development
        ExplicaÃ§Ã£o do fluxo mais simples com commits diretos no main.
- PrÃ¡ticas Recomendadas
- Ferramentas Complementares
    - ExtensÃµes para VSCode
        - GitLens (visualizaÃ§Ã£o de histÃ³rico e autoria).
        - Git Graph (visualizaÃ§Ã£o de branches).
    - IntegraÃ§Ã£o com GitHub/GitLab:
        GitHub Actions (para CI/CD).
        GitLab Pipelines.

### Mercurial  (ğŸš§)

## Extra
**Desafios sobre conhecimentos tÃ©cnicos**

Este tipo de teste geralmente Ã© aplicado em oportunidades de trabalho em projetos internacionais, entre diversas plataformas que existem, eu atualmente recomendo essas duas para ajudar na preparaÃ§Ã£o e/ou melhorar os conhecimentos tÃ©cnicos aplicados.

[Hacker Rank](https://www.hackerrank.com/dashboard)

[Coding Game](https://www.codingame.com/ide/puzzle/onboarding)

**InglÃªs**
- GramÃ¡tica

	[Aplicativo Duolingo](https://pt.duolingo.com/) (Bom conteÃºdo na versÃ£o gratuita)

	[Aplicativo EWA](https://appewa.com/) (Bom conteÃºdo na versÃ£o gratuita)
	
- PronÃºncia
  
	[Aplicativo Elsa Speak](https://elsaspeak.com/pt/) (Bom conteÃºdo na versÃ£o gratuita, recomendo a assinatura anual)
	
- ConversaÃ§Ã£o

	[Cambly](https://www.cambly.com/invite/Y4KYMJXD?st=120623&sc=4) (Pago, recomendo a assinatura anual)

- CorreÃ§Ã£o de Escrita

  	[Grammarly](https://app.grammarly.com/) (Boa versÃ£o gratuita, recomendo uso no site, extensÃ£o no navegador e tambÃ©m teclado no Android e IOs)
	
  	[Chat GPT](https://chat.openai.com/) (Pode ser usado para traduzir texto de qualquer idioma para qualquer idioma, ou corrigir texto no idioma desejado)
	
	Recomendo o uso das duas ferramentas, seja apenas pra comunicaÃ§Ã£o bÃ¡sica como responder emails, criar LinkedIn, currÃ­culo e etc em inglÃªs, quanto pra uso no dia a dia. Recomendo usar as duas ferramentas ao mesmo tempo, pois nas 2 acontecem pequenos erros, assim com o uso das 2 e uma noÃ§Ã£o bÃ¡sica do inglÃªs Ã© possÃ­vel escrever texto, mensagens, etc quase que perfeitos em inglÃªs e melhorar o conhecimento no idioma no processo!

## LinkedIn (ğŸš§)
