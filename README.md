[![Hits](https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https%3A%2F%2Fgithub.com%2FJhonnySMarcelo%2FLearning&count_bg=%2379C83D&title_bg=%23555555&icon=&icon_color=%23E7E7E7&title=Views&edge_flat=false)](https://hits.seeyoufarm.com)


# Learning (🚧 **Em Construção** )

## Programação (🚧)

## Banco de Dados (🚧)
### Relacional (Sequel, SQL) (🚧)
**SQL Server** (🚧)
- Configuração do Ambiente de desenvolvimento (🚧)
- Modelagem de Dados (🚧)
- Consultas SQL (🚧)
- Funções de Agregação e Operações de Conjuntos (🚧)
- Stored Procedures (🚧)
- Triggers (🚧)
- Índices (🚧)
- Visões (Views) (🚧)

### Não Relacional (NoSQL) (🚧)

### Back-end (🚧)
[C# .Net](Back-end/C%23_DotNet.md) (🚧)
- Configuração do Ambiente de desenvolvimento(🚧)
- Lógica de programação (🚧)
	- Algoritmos e sua importância (🚧)
	- Variáveis e tipos de dados (🚧)
	- Operadores lógicos e relacionais (🚧)
    - Estruturas condicionais (if, else, switch) (🚧)
    - Estruturas de repetições Loops (for, while, do-while) (🚧)
    - Controle de fluxo (break, continue) (🚧)
    - Definição e aplicação de funções (🚧)
    - Passagem de parâmetros (por valor, por referência) (🚧)
    - Funções recursivas (🚧)
		- Conceitos básicos de recursão (🚧)
		- Aplicações práticas de recursão (🚧)
    - Manipulação de strings e caracteres (🚧)
- Estrutura de dados (🚧)
	- Definição e aplicação (🚧)
	- Arrays e Matrizes (🚧)
    - Operações básicas (inserção, remoção, acesso)  (🚧)
	- Listas Ligadas  (🚧)
		- Simplesmente encadeadas (🚧)
		- Duplamente encadeadas (🚧)
	- Pilhas e Filas (🚧)
	- Árvores (🚧)
		- Árvores binárias (🚧)
	- Grafos (🚧)
		- Representação de grafos (🚧)
    - Algoritmos de busca em grafos (🚧)
	- Tabelas Hash (🚧)
- Programação Orientada a Objetos POO (Object Oriented Programming, OOP) (🚧)
	- Conceitos Fundamentais de POO (🚧)
	- Classes e Objetos (🚧)
	- Encapsulamento, Herança e Polimorfismo (🚧)
	- Abstração e Interfaces (🚧)
	- Delegates e Eventos (🚧)
	- Extension Methods e Operator Overloading (🚧)
	- Finalizadores (Destructors) e IDisposable (🚧)
- Acesso a Dados (🚧)
  -  Mapeamento objeto-relacional (Object-Relational Mapping, ORM) (🚧)
	- Eager Loading (🚧)
	- Lazy Loaging (🚧)
	- Entity FrameWork Core (🚧)
		- Configuração e Mapeamento (🚧)
		- Relacionamentos e Consultas (🚧)
	- Dapper (🚧)
 	- Provedores de dados (Data Providers) (🚧)
		- ADO.Net (🚧)
		- DevArt dotConnect (🚧)
- Autenticação e Autorização (🚧)
  - Autenticação Baseada em Cookies (🚧)
  - Autorização Baseada em Funções (Role-Based Authorization)    (🚧)
  - JSON Web Token (JWT) (🚧)
  - OAuth e OpenID Connect (🚧)
  - Autorização Baseada em Claims (Claim-Based Authorization) (🚧)
  - Controle de Acesso Baseado em Recursos (Resource-Based Access Control) (🚧)
-  ASP.NET (🚧)
	- Introdução ao ASP.NET (🚧)
	- Web API arquitetura RESTful (🚧)
		- APIs baseadas em controlador (Controller-based APIs) (🚧)
		- APIs mínimas (Minimal APIs) (🚧)
		- Webhooks (🚧)
	- Paginas Web (Web App) (🚧)
		- MVC Modelo-Visualização-Controlador (Model-View-Controller) (🚧)
		- Páginas Razor (🚧)
- Logs (Registros) e Monitoramento  (🚧)
	- Implementação de Logs Simples  (🚧)
	- Implementação de Logs Estruturado e Análise de Logs (🚧)
- Arquitetura de Software (🚧)
	- Definição e importância da arquitetura de software.
    - Princípios fundamentais (Separation of Concerns, Modularity, etc.).
    - Qualidades Arquiteturais (Performance, Scalability, Security, etc.).
    - Estilos Arquiteturais
		- Monolithic (Monolítico)
		- Microservices (Microsserviços)
		- Event-Driven (Orientado a Eventos) (🚧)
		- N-tier Architecture (Arquitetura Multicamadas) (🚧)
		- Serverless (Sem Servidor) (🚧)
- Padrões Arquiteturais
    - MVC (Model-View-Controller) (🚧)
    - SOA (Service-Oriented Architecture) (🚧)
    - Layered Architecture (🚧)
    - Clean Architecture (🚧)
    - Ports and Adapters (Hexagonal Architecture) (🚧)
    - Documentação (UML, C4, etc.).
- Padrões de Projeto (Design Patterns) (🚧)
	- Introdução aos Padrões de Projeto (🚧)
	- Padrões Creational (🚧)
	- Padrões Structural  (🚧)
	- Padrões Behavioral (🚧)
- Princípios de Design de Software (Software Design Principles) (🚧)
	- Princípios SOLID (🚧)
		- S - Single Responsibility Principle (SRP): Uma classe deve ter apenas uma responsabilidade ou motivo para mudar.
        - O - Open/Closed Principle (OCP): Entidades de software devem estar abertas para extensão, mas fechadas para modificação.
        - L - Liskov Substitution Principle (LSP): Objetos de uma classe base devem poder ser substituídos por objetos de uma classe derivada sem alterar o comportamento esperado.
        - I - Interface Segregation Principle (ISP): Uma interface deve ser específica para um cliente, não genérica para vários clientes.
        - D - Dependency Inversion Principle (DIP): Dependa de abstrações e não de implementações concretas.
    - Princípios de Simplicidade (🚧)
		- KISS (Keep It Simple, Stupid): Mantenha o design e o código o mais simples possível.
		- YAGNI (You Aren't Gonna Need It): Não adicione funcionalidades até que realmente precise delas.
    - Princípios de Modularidade e Encapsulamento (🚧)
        Separation of Concerns (SoC): Divida o sistema em partes distintas que lidam com diferentes aspectos.
        Encapsulation (Encapsulamento): Proteja os dados e comportamentos internos de um objeto, expondo apenas o necessário.
    - Princípios de Acoplamento e Coesão (🚧)
        Law of Demeter (Lei de Demeter): Um objeto deve interagir apenas com seus amigos diretos e não com os amigos dos amigos.
        Tell, Don't Ask (Diga, Não Pergunte): Diga ao objeto o que fazer diretamente, sem perguntar sobre seu estado.
    - Princípios de Flexibilidade e Evolução (🚧)
        Favor Composition Over Inheritance (Prefira Composição à Herança): Utilize composição em vez de herança para criar sistemas flexíveis.
        Principle of Flexibility (Princípio da Flexibilidade): O design deve permitir mudanças e extensões futuras com facilidade.
    - Princípios de Robustez e Manutenção (🚧)
        DRY (Don't Repeat Yourself): Evite duplicação de código e lógica.
        Principle of Maintainability (Princípio da Manutenibilidade): O código deve ser fácil de entender, corrigir e atualizar.
        Principle of Robustness (Princípio da Robustez): O sistema deve lidar com condições inesperadas e erros de forma eficaz.
    - Princípios de Abstração e Interação (🚧)
        Principle of Abstraction (Princípio de Abstração): Esconda detalhes complexos e forneça uma interface simplificada.
        Single Source of Truth (Fonte Única da Verdade): A informação deve ser representada em um único lugar para garantir consistência.
    - Princípios de Design de Interface (🚧)
        Principle of Least Astonishment (Princípio do Menor Espanto): O design deve ser previsível para minimizar a surpresa e a confusão.
- Integração com SDLC e DevOps (🚧)
	- SDLC (Software Development Life Cycle) (🚧)
		- Modelos de SDLC (Waterfall, Agile, etc.) (🚧)
		- Aplicação das fases do SDLC no desenvolvimento .NET (🚧)
    - DevOps (🚧)
		- Conceitos Fundamentais de DevOps (🚧)
		- Automação de Processos de Desenvolvimento e Operações (🚧)
		- Ferramentas como Docker, Kubernetes (🚧)
		- CI/CD com .NET (🚧)
### Front-end (🚧)
- HTML 5 (HyperText Markup Language) (🚧)
- CSS 3 (Cascading Style Sheets) (🚧)
- JavaScript (🚧)
	- Vanilla (🚧)
	- TYPESCRIPT (🚧)
- Bootstrap (🚧)

## Angular (🚧)
- Introdução ao Angular (🚧)
- [Configuração do Ambiente de Desenvolvimento (🚧)](Front-end/Angular/Configuração_do_Ambiente_de_Desenvolvimento.md)
- Angular CLI (🚧)
- Componentes e Templates (🚧)
- Serviço e Injeção de dependência (Dependency injection) (🚧)
- Data Binding (Interpolação, Propriedade, Evento, Duas Vias (Two-Away)) (🚧)
- Diretivas (Estruturais, Atributo )(🚧)
- Operador Elvis ("?") (🚧)
- Pipes (🚧)
- Formulários (🚧)
- Roteamento (🚧)
- Integração com Servidor (🚧)
- Comunicação com Backend e Observables (🚧)

### Mobile

### Flutter
- Introducão ao Flutter
- Command Line Interface (CLI)
	- Slidy 
- Sistema de injeção de depência e controle de rotas
	- Modular
- Gestão de estado
	- MOBX 
- Linguagem de design
	- Material Design 
- Persistência de Dados 

## Versionamento de Código (🚧)
### Git  (🚧)

### Mercurial  (🚧)

## Extra
**Desafios sobre conhecimentos técnicos**

Este tipo de teste geralmente é aplicado em oportunidades de trabalho em projetos internacionais, entre diversas plataformas que existem, eu atualmente recomendo essas duas para ajudar na preparação e/ou melhorar os conhecimentos técnicos aplicados.

[Hacker Rank](https://www.hackerrank.com/dashboard)

[Coding Game](https://www.codingame.com/ide/puzzle/onboarding)

**Inglês**
- Gramática

	[Aplicativo Duolingo](https://pt.duolingo.com/) (Bom conteúdo na versão gratuita)

	[Aplicativo EWA](https://appewa.com/) (Bom conteúdo na versão gratuita)
	
- Pronúncia
  
	[Aplicativo Elsa Speak](https://elsaspeak.com/pt/) (Bom conteúdo na versão gratuita, recomendo a assinatura anual)
	
- Conversação

	[Cambly](https://www.cambly.com/invite/Y4KYMJXD?st=120623&sc=4) (Pago, recomendo a assinatura anual)

- Correção de Escrita

  	[Grammarly](https://app.grammarly.com/) (Boa versão gratuita, recomendo uso no site, extensão no navegador e também teclado no Android e IOs)
	
  	[Chat GPT](https://chat.openai.com/) (Pode ser usado para traduzir texto de qualquer idioma para qualquer idioma, ou corrigir texto no idioma desejado)
	
	Recomendo o uso das duas ferramentas, seja apenas pra comunicação básica como responder emails, criar LinkedIn, currículo e etc em inglês, quanto pra uso no dia a dia. Recomendo usar as duas ferramentas ao mesmo tempo, pois nas 2 acontecem pequenos erros, assim com o uso das 2 e uma noção básica do inglês é possível escrever texto, mensagens, etc quase que perfeitos em inglês e melhorar o conhecimento no idioma no processo!

## LinkedIn (🚧)
